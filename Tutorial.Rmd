---
title: "BarCluster Tutorial"
author: "Lee Richman"
date: "01/11/2022"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(magrittr)
library(BarCluster)
library(data.table)
library(Seurat)
library(ggplot2)

```

# Walkthrough

Welcome to BarCluster. This RMarkDown file is a tutorial using sample data to generate hybrid clusters from lineage barcoded single cell sequencing data. We will:

  1. Read in our data (count matrix and barcode assignments).

  2. Run PCA on our count matrix.

  3. Create our hybrid clusters across a range of values.

  4. Determine alpha values for analysis based on cluster number at fixed resolution.

  5. Generate Sankey plots to show cluster rearrangement.

  6. Identify cluster markers with ROC analysis.

  7. Plot a Sankey for marker positivity.

  8. Perform UMAP and warp it!


## Part 1: Setup

Load required packages, get our tutorial data files:

```{r setupshow, message = FALSE}

library(data.table)
library(magrittr)
library(Seurat)
library(BarCluster)
library(ggplot2)

# get the location of the sample data
dir <- system.file(package = "BarCluster") %>% file.path(., "extdata")

cm <- file.path(dir, "YG1_sample_genes.txt")

bt <- file.path(dir, "YG1_sample_barcodes.txt")

```

Now lets read in and see what our files look like.

```{r fread}

# read in barcodes
bt <- data.table::fread(bt)

# what does it look like
head(bt)

# read in count matrix
cm <- data.table::fread(cm)

# what does it look like
str(cm)

```

Everything read in correctly but the count matrix is formatted with cells as columns (a common output format). BarCluster expects cells as rows. No problem, I've included functions in BarCluster to reformat the data.table.

```{r transpose}

# transpose the table

cm <- tdt(cm)

# what does it look like?
str(cm)

```

Looks good. Ok, one last setup step, turn out count matrix from a data table into a matrix.

```{r matrix}

# convert data table to matrix

cm <- dt2m(cm)

# what does it look like?
str(cm)

```

## Part 2: Perform PCA.

The next step is to generate our PCA matrix. The function `irlba_wrap` is a wrapper that will do this for you. You can set the random seed and the number of output PCs if you want, see `?irlba_wrap`. For this analysis, let's summarize our 501 genes to 25 PCs:

```{r pca}
# using 25 PCs
pca <- irlba_wrap(cm, npc = 25)

str(pca)

```

## Part 3: Generate hybrid clusters across a range of alpha values.

The steps to perform hybrid clustering are:

  1. Generate transcriptome shared nearest neighbor graph

  2. Generate binary barcode graph

  3. Integrate the two with the BarCluster model

  4. Repeat for many values of alpha to determine max alpha with tolerable cluster numbers.

Luckily, this is all executed with a single function whose inputs are the barcode table and the PCA we just made. The `barcluster` function does all this for one or more alpha values. The `beta` parameter will affect how each step in alpha affects the output, we are using 0.1 here, but feel free to experiment. The `res` argument is passed to the `Seurat` implementation of the Louvain algorithm. It will affect the number of clusters at low alpha, but at high alpha the determining factor is the number of barcodes in the sample. I suggest you choose a value for resolution that gives you a number of manageable clusters at alpha == 0, or simply the same value as whatever Seurat analysis you have performed on the data.

```{r barclusterinc, eval = FALSE}

# lets get our range of alpha values

als <- seq(0, 1, by = 0.1)

# return the cluster assignments for range of alphas
clust <- barcluster(pca, bt, alpha = als, beta = 0.1, res = 1.5)

print(clust)

```

```{r barclusternotinc, include = FALSE}

# lets get our range of alpha values

als <- seq(0, 1, by = 0.1)

# return the cluster assignments for range of alphas
clust <- barcluster(pca, bt, alpha = als, beta = 0.1, res = 1.5)

```

```{r barclusternotinc2, include = FALSE}

print(clust)

```

These are your hybrid clusters.

## Part 4: Identify target alpha values

`clust` is a data table with the cluster assignment of each cell at all alpha values. First, lets identify points to conduct our analysis by making a plot of cluster number vs alpha.

```{r plotn}

nt <- clust[, Group %>% unique %>% length, by = "alpha"]

ggplot(nt, aes(x = alpha, y = V1)) +
  geom_point(color = "dodgerblue") +
  geom_line(color = "grey", linetype = "dashed") +
  theme_bw() +
  ttheme +
  xlab("\u03B1") +
  ylab("# of clusters") +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1))

```

It looks like there are four interesting points on the plot for this sample data (downsampled for top barcodes and 100 singlets from the WM989 high dose BRAF inhibitor replicate 1). I'll annotate them here:

```{r plotnanno, echo = FALSE}

ggplot(nt, aes(x = alpha, y = V1)) +
  geom_point(color = "dodgerblue") +
  geom_line(color = "grey", linetype = "dashed") +
  theme_bw() +
  ttheme +
  xlab("\u03B1") +
  ylab("# of clusters") +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  geom_text(data = nt[alpha %in% c(0, 0.2, 0.4, 0.9)],
  aes(x = alpha), y = 20, label = "*", size = 8)

```

From left to right, these points are the transcriptome clusters (alpha == 0), a nadir where addition of lineage information causes clusters to join (alpha == 0.2), the inflection point (alpha == 0.4), the the maximum value before clusters break apart into barcodes (alpha == 0.9).

## Part 5: Sankey visualization

Let's make a sankey plot to see the reorganization, subsetted on our alphas of interest. You could do this on the full range of alphas we ran by omitting the brackets and their contents after `clust` in the next call, but 100+ nodes on a sankey requiring individual discrete colors is not easy to grok.

```{r sankey}

notable_alphas <- c(0, 0.2, 0.4, 0.9)

p <- Plot_alluvia(clust[alpha %in% notable_alphas],
                  bt,
                  title = "Sample Sankey",
                  xlab = "\u03B1", # unicode symbol for alpha
                  ylab = "# of cells",
                  border_size = 1,
                  label_nodes = FALSE, # labels nodes but hard to viz here
                  cols = BarCluster::c25
                  )

p[[2]] <- p[[2]] + ggtitle("Sample Sankey", subtitle = "Colored by \u03B1 = 0.9 clusters")

p

```

## Part 6: Identify cluster markers.

Let's find the top cluster marker per cluster at each level. We will do this for ROC analysis for in vs out of cluster cells across all genes in the count matrix. I've written a function to make this easier. This is not fast however. If you already have a Seurat object, this may be quicker by input clusters as the active identity and using the `Seurat::FindAllMarkers` function. If you want to skip this step and just go right to the discovered markers, see the hashed annotations in this code.

```{r findmarkers}

# to skip this step:
# auc_table <- data.table::fread("YG1_markers.txt")
auc_table <- Find_Markers_ROC(clust[alpha %in% notable_alphas], cm)

# you can save this table with:
# auc_table %>% data.table::fwrite("mytable.txt")

# what does it look like?
head(auc_table)

# Take the best auc for any cluster at each alpha
auc_table <- auc_table[order(-auc)] %>% unique(by = c("rn", "alpha"))

```

## Part 7: Tracking marker positivity by Sankey

It may be useful to look at how marker strength changes across hybrid clusters. To assess this, we will first take the best possible AUC for each marker at each alpha and make a wide table to look at strength.

```{r widen, messages = FALSE}

aucw <- auc_table[, auc, by = c("alpha", "rn")] %>%
  dcast(rn ~ alpha)

# table of marker strength
head(aucw)

```

Let's identify some markers to plot it on Sankey.

```{r 2marker}

aucw[, delta := `0` - `0.9`]

# marker that falls off the most
transcriptome_only <- aucw[order(-delta), rn[1]]

# marker that improves the most
alpha_enhanced <- aucw[order(delta), rn[1]]

print(c(transcriptome_only, alpha_enhanced))

```

Let's plot the transcriptome_only marker. We will **put in cluster, marked cells in purple** and **out of cluster marked cells in grey**.

```{r tomarker}

# get the transcriptome cluster that the is the most effective for our marker
at <- auc_table[alpha == 0 & rn == transcriptome_only]

# get our marked cluster members
cluster_members <- clust[alpha == 0 & Group == at[, Group], rn]

# retrieve marked cells
all_pos <- rownames(cm)[cm[, transcriptome_only] > at[, thresh]]

# check if the sign is flipped for the AUC
if (at[, direction == "less"])
  all_pos <- rownames(cm)[cm[, transcriptome_only] < at[, thresh]]

# get true positives (in cluster, positive)
tp <- intersect(cluster_members, all_pos)

# get false positives (out of cluster, positive)
fp <- all_pos[!all_pos %chin% cluster_members]

# generic plotting function, tracks any group of cells as a ribbon
p <- Plot_alluvia_track(clust[alpha %in% notable_alphas],
                          ids = list(fp, tp),
                          title = paste0(transcriptome_only, "-positivity"),
                          xlab = "\u03B1",
                          ylab = "# of cells",
                          label_nodes = FALSE,
                          border_size = 1,
                          flow_alpha = 1,
                          cols = c("grey80", "purple")
                        )

# put table in the same order as the plot
auc_table %<>% .[order(alpha)]

# AUC annotations
lab <- paste0("AUC: ", auc_table[rn == transcriptome_only]$auc %>%
  `/`(.,100) %>% sprintf(fmt = "%.2f"))

# add AUC annotations
p <- p +
  annotate("text", x = 1:4,
  y = nrow(bt) * 1.1, label = lab, fontface = "bold")

# add text theming
p <- p + ttheme

p

```

Let's plot an alpha-enhanced marker this time. We will **put in cluster, marked cells in purple** and **out of cluster marked cells in grey**.

```{r aemarker}

# get the hybrid cluster that the is the most effective for our marker
at <- auc_table[alpha == last(notable_alphas) & rn == alpha_enhanced]

# get our marked cluster members
cluster_members <- clust[alpha == last(notable_alphas) & Group == at[, Group], rn]

# retrieve marked cells
all_pos <- rownames(cm)[cm[, alpha_enhanced] > at[, thresh]]

# check if the sign is flipped for the AUC
if (at[, direction == "less"])
  all_pos <- rownames(cm)[cm[, alpha_enhanced] < at[, thresh]]

tp <- intersect(cluster_members, all_pos)

fp <- all_pos[!all_pos %chin% cluster_members]

p <- Plot_alluvia_track(clust[alpha %in% notable_alphas],
                          ids = list(fp, tp),
                          title = paste0(alpha_enhanced, "-positivity"),
                          xlab = "\u03B1",
                          ylab = "# of cells",
                          label_nodes = FALSE,
                          border_size = 1,
                          flow_alpha = 1,
                          cols = c("grey80", "purple")
                        )

auc_table %<>% .[order(alpha)]

lab <- paste0("AUC: ", auc_table[rn == alpha_enhanced]$auc %>%
  `/`(.,100) %>% sprintf(fmt = "%.2f"))

p <- p +
  annotate("text", x = 1:4,
  y = nrow(bt) * 1.1, label = lab, fontface = "bold")

p <- p + ttheme

p

```

## Part 8: UMAP and Warp Factor the data

For the last part of our analysis, lets explore our barcodes and clusters in UMAP space. We will start by visualizing our clustering alphas in default UMAP space.

```{r topmarkers}

# lets do multiple warp factors
wfs <- c(0, 2, 4, 6, 8, 10)

# get our warped UMAPs
umaps <- lapply(wfs, function(s){

  mo <- barcode_warp(pca, bt, s)

  um <- umap_matrix(mo)

  um[, warp := s]

}) %>% data.table::rbindlist()

# add our barcodes to the table

umaps <- merge(umaps, bt, by = "rn")

# color by barcode and put singlets into one category
umaps[, Barcode :=
        ifelse(rn %>% unique %>% length > 1, Barcode, "Singlet"),
        by = "Barcode"]

# add transcriptome clusters, rename column, make discrete
umaps <- merge(umaps, clust[alpha == 0, .(rn, Group)], by = "rn") %>%
  setnames("Group", "Transcriptome") %>%
  .[, Transcriptome := as.factor(Transcriptome)]

# add low alpha clusters, rename, make discrete
umaps <- merge(umaps, clust[alpha == notable_alphas[2], .(rn, Group)], by = "rn") %>%
  setnames("Group", "Low_alpha") %>%
  .[, Low_alpha := as.factor(Low_alpha)]

ums <- lapply(c("Transcriptome", "Low_alpha", "Barcode"), function(g){

  um <- ggplot(umaps, aes(x = UMAP_1, y = UMAP_2)) +
    geom_point(aes_string(col = g), size = 0.3, alpha = 0.5) +
    facet_wrap(~warp) +
    scale_color_manual(values = c25) +
    ttheme +
    theme_void() +
    theme(legend.position = "bottom")

    return(um)

})

```

Let's have a look at how our UMAP looks with increasing warp factor:

Colored by transcriptome clusters.

```{r um1}

um[[1]]

```

Colored by low alpha clusters.

```{r um2}

um[[2]]

```

Colored by barcodes.

```{r um3}

um[[3]]

```
